On Wed, Mar 8, 2023 at 9:37â€¯PM Sean Sweeney <ssween2@pdx.edu> wrote:
Alright, I think your problem is in getNextThreadStartIndex() (hope I got that name right but I'm sure you know which function I'm talking about). Do away with that, the algorithm here is actually much simpler than the one this code implements. And I also don't think this function works - every time its called thread_current_index just gets initialized to 1. I see what you were going for and its not a bad idea at all. The fix is pretty easy too. 

That you got a non-used variable warning for the only argument you passed to each thread is a hint - you should be using that argument. 

Say I've got four threads, spun up with tid 0,1,2,3. The first thread, tid=0 can start by checking all of the numbers divisible by 3. And the thread tid=1 can start at 5 and so on (2 starts at 7, 3 starts at 9). So the first argument of your outer for loop just needs some algebra - thread_index = 3+2*thread_id. That'll make sure every thread starts at a distinct number and no thread tries to duplicate any work. 

The middle condition of that outer for loop (and I am talking about the loop on line 96 of primesMT.c) is fine - just go up to the ceiling of the sqrt of the upper limit. 

The trick to making sure they don't replicate any work is the last part of that outer for loop. Rather than just find the next odd (which might work but is super tricky and the code, as is, will not work) simply increment the thread_index by 2*num_threads. That way tid=0 will be at 11 (3+2*4=11, the next odd you haven't checked) and tid=1 will be at 13 (5+2*4=13) and so on. Each thread will only cover ciel(sqrt(upper_limit)/num_threads  number of divisors to check, so the work is split evenly(ish). I hope this little explanation makes sense, if not please let me know and I'll try to expand on it. 

As a little side note about your getNextThreadStartPosition function - not only is thread_current_index just being set to 1 every time this gets called, but the lock is also a different lock, local to each function call, lock every time. So even if thread_current_index were a global value, the threads would have a race condition in changing that thread_current_index value, which would cause problems. 

I hope the better algorithm as described makes sense. Your code is very nice otherwise. Also, I didn't really look at the makefile you sent because I figured that wasn't the issue pretty quickly. Happy to look at that if needed (though I don't think it is) and also, again, happy to do a little more detail on the algorithm. The gist is to use the argument you passed to each thread to determine which numbers it is going to check for divisibility. Hope all this helps!